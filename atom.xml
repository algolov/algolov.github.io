<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Александр Головко]]></title>
  <link href="http://algolov.github.io/atom.xml" rel="self"/>
  <link href="http://algolov.github.io/"/>
  <updated>2015-01-13T01:53:23+10:00</updated>
  <id>http://algolov.github.io/</id>
  <author>
    <name><![CDATA[Golovko Aleksander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Заметки о полиморфизме в Scala]]></title>
    <link href="http://algolov.github.io/blog/2014/11/20/polimorphism-in-scala/"/>
    <updated>2014-11-20T02:08:41+10:00</updated>
    <id>http://algolov.github.io/blog/2014/11/20/polimorphism-in-scala</id>
    <content type="html"><![CDATA[<p>В этой статье мы попробуем разобраться с тем, что такое полиморфизм, для чего он нужен и какой он бывает. А также мы посмотрим на то как те или иные его проявления реализуются в языке Scala.</p>

<!-- more -->


<blockquote><p>я планировал написать этот пост для habrahabr.ru, но так как времени довести его до ума у меня критически не хватает, то я решил опубликовать его &ldquo;как есть&rdquo;, ибо он и так уже пропылился у меня 2 месяца в черновиках. Так что, чтобы он не пропал в туне, я решил выложить его в своем блоге.</p></blockquote>

<p>Разговор о полиморфизме - это разговор о системе типов, потому что полиморфизм является свойством ситемы типов языка. А основная задача системы типов, это сокращение ошибок в программах, поэтому типы накладывают своего рода ограничения, которые помогают усилить корректность программ. Scala - язык с сильной, статической типизацией и обладает мощной системой типов. В языках со статической типизацией типы всех переменных и выражений должны быть определены на этапе компиляции, что является довольно строгим ограничением. Так вот, полиморфизм позволяет увеличить гибкость и выразительность языка, сохраняя при этом безопасность типов, даже если тип выражения статически не известен.</p>

<p>Полиморфизм бывает четырех видов, которые в общем объединяются в две категории:</p>

<ol>
<li>Универсальный (Universal)

<ul>
<li>Параметрический полиморфизм (parametric polymotphism/generics)</li>
<li>Полиморфизм включения (including polimorphism/subtyping)</li>
</ul>
</li>
<li>Cпециальный (Ad-hoc)

<ul>
<li>Перегрузка (overloading) и Тайпклассы (typeclasses)</li>
<li>Приведение типов (coercion)</li>
</ul>
</li>
</ol>


<p>Существует также некоторые разночтения в терминах, например в ООП мире параметрический полиморфизм в основном называют <code>generics</code> (обобщенное программирование), в то время как в мире ФП такой тип полиморфизма называют просто <code>полиморфизм</code>. В то же время в ООП просто полиморфизмом называют полиморфизм включения, его еще называют выделением подтипа (subtyping или subtype polimorphism). В этой статье мы коснемся универсального полиморфизма.</p>

<h2>Универсальный полиморфизм</h2>

<p>Особенность универсально полиморфных функций и типов в том, что они могут <em>одинаково</em> обработать (потенциально) бесконечное количество типов. Такая особенность может достигаться разными способами.<br/>
Например, использование параметрического полиморфизма позволяет создавать обобщенные функции и типы данных, указывая вместо действительных типов (таких как Int, String) - переменные типов, вместо которых, в последствии, будут подставлены действительные типы. Такая возможность позволяет обрабатывать значения независимо от их типа. В случае использования полиморфизма включения поведение полиморфной функции ограничивается множеством типов, связанных иерархией наследования (отношения супертип-подтип).</p>

<p>Связь этих двух подвидов универсального полиморфизма, обеспечивается посредством связанной квантификации и вариантности конструкторов типов. При программировании в Scala оба этих вида тесно переплетаются между собой, поэтому нет смысла разделять их на отдельные темы, я просто буду указывать где проявляется тот или иной вид.</p>

<p>Для того, что бы лучше понять применение полиморфизма давайте представим, что мы решили написать свою библиотеку для работы с коллекциями. В нашем случае мы будем рассматривать пример реализации списка. Начнем с того, что определим список целых чисел:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IntList</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Int</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IntList</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="s">&quot;Nil&quot;</span> <span class="k">else</span> <span class="n">s</span><span class="s">&quot;$head :: ${tail.toString}&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">IntList</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="k">throw</span>  <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;Nil.head&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">throw</span>  <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;Nil.tail&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cons</span><span class="o">(</span><span class="k">val</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IntList</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IntList</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Реализация нашего списка состоит из трех частей, это базовый тип <code>IntList</code> и наследующие от него класс <code>Cons</code> и объект <code>Nil</code>. Такая структура представляет собой пример полиморфизма включения. Благодаря такому полиморфизму, мы можем использовать <code>Cons</code> и <code>Nil</code> там, где требуется <code>IntList</code></p>

<p>Рассмотрим реализацию более подробно.</p>

<p>Итак, в первой строке мы объявили новый тип данных <code>IntList</code>. Слово <code>trait</code> в определении типа говорит о том, что данный тип является чем-то вроде интерфейсов в Java, с той разницей (не единственной), что может содержать не только абстрактные методы (такие как <code>isEmpty</code>, <code>head</code>, <code>tail</code>), но и методы с реализацией (например <code>toString</code>). Как и интерфейсы в Java мы не можем напрямую создать экземпляр трейта при помощи ключевого слова <code>new</code>.  Слово <code>sealed</code> перед <code>trait</code> означает, что все реализации данного трейта должны быть помещены в тот же самый файл, где объявлен наш трейт. Таким образом, наш список может конструироваться только при помощи строительных блоков которые мы предоставим - <code>Cons</code> и <code>Nil</code>, они так же называются <em>конструкторами данных</em>.</p>

<blockquote><p>В принципе, так как функциональность базового типа будет использоваться только двумя наследниками и мы не планируем предоставлять возможность наследования от <code>List</code> в каких-то других несвязанных классах, то с тем же успехом можно было использовать <code>abstract class</code> вместо <code>trait</code>, характеристик абстрактного класса было бы вполне достаточно, к тому же такой вариант будет немного более производительным. Но в рамках статьи это не имеет особого значения, поэтому здесь и далее будет использован именно трейт.</p></blockquote>

<p>Конструктор <code>Nil</code>, создает пустой список и так как он не содержит элементов, то операции доступа к ним вызывают исключения. Мы будем использовать его как маркер конца не пустого списка. Конструктор не пустого списка <code>Cons</code> содержит первый элемент и список остальных элементов, который может быть в том числе и пустым списком. Используя ключевое слово <code>case</code> при объявлении конструкторов списка, мы получаем некоторые преимущества над обычными классами. Например, case-классы могут использоваться при сопоставлении с образцом (pattern matching), таким образом позволяя деконструировать список. Также, для <code>case</code>-классов создается объект-компаньон содержащий метод <code>apply</code> позволяющий создавать экземпляры класса без ключевого слова <code>new</code>, а параметры конструктора становятся публичными полями класса. В Scala конструктор является частью определения класса, поэтому параметры конструктора в классе <code>Cons</code> становятся публичными и переопределяют абстрактные методы базового класса. Так как <code>Nil</code> не принимает значений в качестве параметров, то мы определяем его как объект-одиночку - <code>case object</code>.</p>

<p>Рассмотрим пример создания списка целых чисел:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">intList</span><span class="k">:</span> <span class="kt">IntList</span> <span class="o">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">intList</span><span class="k">:</span> <span class="kt">IntList</span> <span class="o">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'><span class="n">intList</span><span class="k">:</span> <span class="kt">IntList</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Но что если нам однажды потребуется работать не только с целыми числами, но и с другими типами данных такими как числа с плавающей точкой или строки? Один из вариантов - скопировать реализацию для целых чисел и заменить тип <code>Int</code> на нужный. Но таким образом нам придется повторять это снова и снова для каждого нового типа с которым мы захотим работать, при этом код будет разрастаться, что увеличит количество ошибок, усложнит рефакторинг и т.д и т.п. Если посмотреть более пристально на наш список, то можно заметить, что его функциональность никак не зависит от типа содержащихся в них данных. Поведение списка пудет одинаковым и для строк и для чисел с плавающей точкой и для объектов пользовательских классов. Было бы очень удобно иметь возможность указать компилятору на то, что какая-либо структура и поведение является общей для всех типов. Как раз для этого мы можем использовать параметрический полиморфизм. Для реализации нашей задумки нам нужно добавить параметр типа и заменить жескто заданный тип <code>Int</code>, на <em>переменную типа</em>, которую мы указываем в качестве <em>параметра типа</em>. Давайте попробуем усовершенствовать нашу реализацию:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// конструктор типа</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="s">&quot;Nil&quot;</span> <span class="k">else</span> <span class="n">s</span><span class="s">&quot;$head :: ${tail.toString}&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="k">throw</span>  <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;Nil.head&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">throw</span>  <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;Nil.tail&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="c1">// конструктор типа</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, прежде чем мы перейдем к деталям того, что и зачем мы изменили, давайте посмотрим на пару примеров использования нашей новой реализации обобщенного списка:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">intList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">3</span><span class="o">,</span><span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">stringList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;uno&quot;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;duo&quot;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;tres&quot;</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">intList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>     <span class="o">|</span>   <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">3</span><span class="o">,</span><span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'><span class="n">intList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stringList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>     <span class="o">|</span>   <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;uno&quot;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;duo&quot;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;tres&quot;</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'><span class="n">stringList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">uno</span> <span class="o">::</span> <span class="n">duo</span> <span class="o">::</span> <span class="n">tres</span> <span class="o">::</span> <span class="nc">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>В первом выражении примера мы объявляем переменную <code>intList</code> в качестве списка целых чисел, заменив формальный параметр <code>T</code> типом <code>Int</code>, затем конструируем список целых чисел при помощи конструктора данных <code>Cons</code>, с передачей действительного параметра - <code>Int</code> и получившийся список присваиваем переменной <code>intList</code>. Во втором выражении мы конструируем список строк и присваеваем его переменной <code>stringList</code> имеющий тип <code>List[String]</code>. Таким образом мы можем использовать одну реализацию списка для данных различного типа.</p>

<p>Давайте же вернемся к самой реализации и перейдем к описанию сделанных изменений. Во-первых, тип данных список целых чисел <code>IntList</code> превратился в полиморфный список - <code>List[+T]</code>. Также, к классам <code>List</code> и <code>Cons</code>, мы добавили новую конструкцию, называемую параметром типа, которая записывается в виде произвольного символьного имени заключенного в квадратные скобки - <code>[+T]</code>, тем самым мы указали, что теперь внутри определений данных классов мы можем использовать имя <code>T</code> в качестве <em>переменной типа</em>, в которую при инстанцировании будет подставлен конкретный тип, такой как <code>Int</code> или <code>String</code>, что было продемонстрированно примерами выше. Полиморфный класс <code>List[+T]</code> также называют <em>конструктором типа</em>, потому что теперь при помощи данного класса вы можете создавать (конструировать) другие типы, просто заменив параметр обобщенного типа на конкретный. То есть конструктор типов <code>List</code> может создавать семейство новых типов, таких как <code>List[Int]</code>, <code>List[String]</code> и так далее. Но параметрический полиморфизм можно применять не только для создания конструкторов типов, но и для обобщения функций. Что бы это продемонстрировать давайте отвлекемся от описания уже сделанных изменений и добавим к нашему списку еще одну функцию, которая будет обеспечивать удобный способ изменения данных, сохраняя при этом общий контекст. Мы назовем данную функцию <code>map</code> и в качестве параметра она будет принимать любую функцию, способную обрабатывать данные хранящиеся в нашем списке и возвращающую новые данные для хранения в новом списке. Но при реализации данной функциональности возникает один важный вопрос. Как быть с тем фактом, что мы не можем за ранее предсказать какой будет тип результата работы такой функции, ведь она будет предоставляться пользователем нашего списка. Как мы уже выяснили, в таких случаях ограничивать реализацию одним типом не очень дальновидно и конечно нам опять поможет параметрический полиморфизм. Для этого к нашей новой функции мы добавим параметр типа, который будет использоваться в качестве переменной типа для результата функции изменяющей данные и для типа данных списка, который получится в результате применения такой функции к элементам исходного списка:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="c1">// полиморфный метод класса List[+T], создает новый список</span>
</span><span class='line'>  <span class="c1">// путем применения переданной функции к каждому элементу списка</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span> <span class="n">f</span> <span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span> <span class="o">)</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">),</span> <span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>И данную функцию можно использовать следующим образом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">intList</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">doubleList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">intList</span><span class="o">.</span><span class="n">map</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">}</span> <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">intList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</span><span class='line'><span class="n">intList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">doubleList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>     <span class="o">|</span>   <span class="n">intList</span><span class="o">.</span><span class="n">map</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">}</span> <span class="o">)</span>
</span><span class='line'><span class="n">doubleList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="mf">0.1</span> <span class="o">::</span> <span class="mf">0.2</span> <span class="o">::</span> <span class="mf">0.30000000000000004</span> <span class="o">::</span> <span class="nc">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>В первом выражении мы конструируем список целых чисел и присваеиваем его переменной <code>intList</code>. Во втором выражении мы вызываем полиморфную функцию <code>map</code> на только что созданном списке и в качестве параметра типа передаем тип <code>Double</code>, который конкретизирует типовую переменную <code>U</code>. Следом за ним в качестве аргумента передаем анонимную функцию, которая в качестве параметра принимает элемент типа <code>Int</code>, а возвращает элемент типа <code>Double</code>.</p>

<blockquote><p>Внимательные заметят, что в первом выражении, конструирование списка целых чисел стало выглядеть чище, потому что исчезли анатации типа у конструктора <code>Cons</code>. На самом деле в Scala можно обойтись без явных анотаций типа, потому что Scala обладает мощной системой вывода типов и может вывести тип выражения даже когда он явно не указан, основываясь, например, на типах аргументов функции или на типе ожидаемого результата. Тем не менее, считается хорошей практикой всегда аннотировать публичные функции и переменные которым присваивается результат сложных выражений. Используя вывод типов и особый синтаксис создания лямбд в Scala, второе выражение из примера выше можно переписать следующим образом: <code>val doubleList = intList.map { _ * 0.1 }</code></p></blockquote>

<p>Итак теперь продолжим описывать сделанные ранее изменения. Мы разобрались с тем как создавать обобщенные типы и функции, но иногда при их реализации можно столкнуться с другими интересными проблемами и решениями. Давайте рассмотрим объект <code>Nil</code>. Так как объект это по сути экземлпяр конкретного (не обобщенного) класса, то объект <code>Nil</code> не может расширять (инстанцироваться от) обощенный тип <code>List[T]</code>. Таким образом нам нужно указать конкретный тип в качестве действительного параметра базового класса, что бы объект <code>Nil</code> был экземпляром конкретного (а не обощенного) типа. Но какой тип указать? Ведь нам нужно что бы <code>Nil</code> мог работать с любым типом, с которым работает <code>List</code>, ведь если мы укажем что <code>Nil</code> является экземпляром типа <code>List[Int]</code>, то мы не сможем его использовать, например, при конструировании списка строк. Но тут нам на помощь придет полиморфизм включения. В частности, мы можем использовать специальный тип <code>Nothing</code>, который является подтипом всех остальных типов в Scala и таким образом может быть передан туда, где ожидаются данные любого другого типа. Поэтому мы указываем, что объект <code>Nil</code> является экземпляром типа <code>List[Nothing]</code>.<br/>
В качестве последнего изменения мы добавили знак <code>+</code> у параметра типа нашего списка <code>List[+T]</code>. Прежде чем объяснить, что это значит, давайте уберем его и попробуем скомпилировать следующий код:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mf">0.5</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mf">0.5</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span><span class='line'> <span class="n">found</span>   <span class="k">:</span> <span class="kt">Nil.type</span>
</span><span class='line'> <span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span><span class='line'><span class="nc">Note</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="k">&lt;:</span> <span class="kt">Double</span> <span class="o">(</span><span class="kt">and</span> <span class="kt">Nil.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]),</span> <span class="n">but</span> <span class="k">trait</span> <span class="nc">List</span> <span class="n">is</span> <span class="n">invariant</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T.</span>
</span><span class='line'><span class="kt">You</span> <span class="kt">may</span> <span class="kt">wish</span> <span class="kt">to</span> <span class="kt">define</span> <span class="kt">T</span> <span class="kt">as</span> <span class="kt">+T</span> <span class="kt">instead.</span> <span class="o">(</span><span class="kt">SLS</span> <span class="err">4</span><span class="kt">.</span><span class="err">5</span><span class="o">)</span>
</span><span class='line'>       <span class="kt">val</span> <span class="kt">l:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mf">0.5</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'>                                               <span class="o">^</span>
</span></code></pre></td></tr></table></div></figure>


<p>В результате мы получим ошибку сообщающую о несоответствии типа, потому что класс <code>List</code> является инвариантным относительно <code>T</code>. Давайте разберем по шагам, что происходит. При создании экземпляра класса <code>Cons</code> в качестве действительного параметра типа указывается тип <code>Double</code>, это значит, что конструктор класса <code>Cons</code> будет ожидать, что ему передадут два значения с типами <code>Double</code> и  <code>List[Double]</code> соответственно. В качестве первого значения мы передаем <code>0.5</code>, что соответствует ожидаемому типу <code>Double</code>, а вот в качестве второго значения мы передаем экземпляр типа <code>List[Nothing]</code> и это не тот тип, который ожидает компилятор. Несмотря на то, что <code>Nothing</code> является подтипом <code>Double</code>, мы не можем сказать того же о типах <code>List[Double]</code>  и <code>List[Nothing]</code>. В Scala все параметризованные типы по-умолчанию инвариантны. Для того, чтобы <code>List[Nothing]</code>, мог рассматриваться в качестве допустимого аргумента, там где ожидается <code>List[Double]</code> мы должны поменять вариантность полиморфного типа <code>List</code>, добавив к параметру типа знак <code>+</code>. Использование типа <code>Nothing</code> и объявление списка контрвариантным к своему параметру типа это пример где параметрический полиморфизм и полиморфизм включения дополняют друг-друга. Давайте рассмотрим эту тему подробнее.</p>

<h3>Вариантность</h3>

<p>В Scala существует возможность проецировать отношения родства между типами на отношения родства между конструкторами типов. То есть указать ответ на вопрос, каким образом два типа имеющие наследственную связь, будут связаны между собой при использовании в полиморфном типе.  По умолчанию все параметрические типы в Scala <em>инвариантные</em>(перед именем формального параметра типа не стоит никаких знаков), так же они могут быть <em>ковариантные</em> (знак <code>+</code> перед именем формального параметра типа) и <em>контравариантные</em> (знак <code>-</code> перед именем формального параметра типа).</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Вариантность   </th>
<th style="text-align:center;"> Значение                                 </th>
<th style="text-align:center;"> Нотация языка Scala     </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ковариант      </td>
<td style="text-align:center;"> C[T’] это подкласс класса C[T]           </td>
<td style="text-align:center;"> [+T]                    </td>
</tr>
<tr>
<td style="text-align:center;"> контрвариант   </td>
<td style="text-align:center;"> C[T] это подкласс класса C[T’]           </td>
<td style="text-align:center;"> [-T]                    </td>
</tr>
<tr>
<td style="text-align:center;"> инвариант      </td>
<td style="text-align:center;"> C[T] и C[T’] не взаимосвязаны            </td>
<td style="text-align:center;"> [T]                     </td>
</tr>
</tbody>
</table>


<p>Что же это значит?</p>

<h4>Ковариантность ([+T])</h4>

<p>Давайте представим, что у нас есть тип данных студент, который является подтипом более общего типа человек:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Person</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">s</span><span class="s">&quot;$name&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Student</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>И на основе отношений родства данных типов возникает вопрос. Считать ли тип <code>List[Student]</code> подтипом более общего типа <code>List[Person]</code>, если следовать логике, то &ldquo;группа студентов&rdquo; это частный случай более общего понятия &ldquo;группа людей&rdquo;, а это значит, что студенты должны обладать всеми качествами людей и поэтому могут быть использованы там, где требуются люди. Значит ответ на наш вопрос должен быть - &ldquo;да&rdquo;. Для того чтобы соответствовать таким отношениям наследственности, наш полиморфный список должен быть ковариантным к своему параметру типа, что обозначается как <code>List[+T]</code>. Более кратко ковариантность можно описать следующим образом: <em>если S подтип T, то С[S] подтип C[T]</em>, что позволяет использовать <em>C[S]</em>, там где на самом деле требуется <em>C[T]</em>. Пример использования ковариантности мы уже видели ранее. Благодаря тому, что наш список ковариантный, мы можем передать <code>Nil</code> в качестве второго параметра конструктора <code>Cons</code>, указав тем самым на конец списка.</p>

<h4>Контравариантность ([-T])</h4>

<p>Существует так же обратный вид вариантности - контравариантность, которая удовлетворяет следующему положению - <em>если T подтип S, то C[S] подтип C[T]</em>, то есть отношения наследования между типами переносятся на конструкторы типов в обратом порядке. Это значит, что список людей <code>List[Person]</code> может рассматриваться в качестве подтипа списка студентов <code>List[Student]</code>. Полезность контравариантности трудно понять интуитивно. Поэтому рассмотрим использование контравариантности на примере.
Так как в Scala функции являются объектами, существует конструктор (в том числе) унарных функций, который мы и рассмотрим в качестве примера. Определяется он следующим образом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T</span>,<span class="kt">+R</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Мы видим, что функция контравариантна к своему аргументу (<code>-T</code>) и ковариантна к своему результату (<code>+R</code>). Давайте теперь создадим некий список студентов:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">students</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">),</span> <span class="nc">Cons</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Jane&quot;</span><span class="o">),</span> <span class="nc">Nil</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Так же определим функцию, которая возвращает имя человека, переданного ей в качестве параметра. Мы определим ее более наглядным способом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">personName</span><span class="k">:</span> <span class="kt">Function1</span><span class="o">[</span><span class="kt">Person</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>Теперь для того, что бы получить список имен всех студентов мы можем написать следующее:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">studentsNames</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">students</span> <span class="n">map</span> <span class="n">personName</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">students</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">),</span> <span class="nc">Cons</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Jane&quot;</span><span class="o">),</span> <span class="nc">Nil</span><span class="o">))</span>
</span><span class='line'><span class="n">students</span><span class="k">:</span> <span class="kt">Cons</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Bob</span> <span class="o">::</span> <span class="nc">Jane</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">personName</span><span class="k">:</span> <span class="kt">Function1</span><span class="o">[</span><span class="kt">Person</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="n">personName</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">studentsNames</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">students</span> <span class="n">map</span> <span class="n">personName</span>
</span><span class='line'><span class="n">studentsNames</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Bob</span> <span class="o">::</span> <span class="nc">Jane</span> <span class="o">::</span> <span class="nc">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Благодаря тому, что <code>Function1</code> контравариантна к своему аргументу, приведенный выше код будет работать без ошибок. Несмотря на то, что функция <code>map</code> в качестве аргумента ожидает функцию типа <code>Student =&gt; String</code>, но мы предоставляем функцию типа <code>Person =&gt; String</code>.
Осталось рассмотреть последний вид вариантности.</p>

<h4>Инвариантность ([T])</h4>

<p>Инвариантность это отсутствие наследственных взаимосвязей относительно параметра типа. Если параметр типа ни ковариантный, ни контравариантный, значит он инвариантный. Инвариантность в основном применяется с изменяемыми структурами данных. Если посмотреть на коллекцию Scala с изменяемыми классами (scala.collection.mutable), то мы увидим что все они инвариантны. Чтобы понять почему, давайте рассмотрим пример с массивами. Предположим, что массивы в Scala ковариантные (на самом деле инвариантны), тогда следующий код был бы корректным с точки зрения компилятора:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">mutableStudents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">))</span>
</span><span class='line'><span class="c1">// boom теперь указывает на тот же массив, что и mutableStudents</span>
</span><span class='line'><span class="k">val</span> <span class="n">boom</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">mutableStudents</span>  <span class="c1">// Так нельзя. Но для примера, представим, что можно</span>
</span><span class='line'><span class="c1">// изменяем первый элемент массива</span>
</span><span class='line'><span class="n">boom</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Oooops&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mutableStudents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">))</span>
</span><span class='line'><span class="n">mutableStudents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">Bob</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">boom</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">mutableStudents</span> <span class="c1">// ошибка не соответствия типов</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span><span class='line'> <span class="n">found</span>   <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span>
</span><span class='line'> <span class="n">required</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
</span><span class='line'><span class="nc">Note</span><span class="k">:</span> <span class="kt">Student</span> <span class="k">&lt;:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">but</span> <span class="k">class</span> <span class="nc">Array</span> <span class="n">is</span> <span class="n">invariant</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T.</span>
</span><span class='line'><span class="kt">You</span> <span class="kt">may</span> <span class="kt">wish</span> <span class="kt">to</span> <span class="kt">investigate</span> <span class="kt">a</span> <span class="kt">wildcard</span> <span class="k">type</span> <span class="kt">such</span> <span class="kt">as</span> <span class="kt">`_ &lt;: Any`.</span> <span class="o">(</span><span class="kt">SLS</span> <span class="err">3</span><span class="kt">.</span><span class="err">2</span><span class="kt">.</span><span class="err">10</span><span class="o">)</span>
</span><span class='line'>       <span class="kt">val</span> <span class="kt">boom:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">mutableStudents</span>
</span><span class='line'>                              <span class="o">^</span>
</span></code></pre></td></tr></table></div></figure>


<p>Данный пример показывает, что если бы массивы были ковариантны, то в <code>mutableStudents</code> уже хранился бы массив не с двумя студентами Bob и Joe, а массив, где вместо Bob&#8217;a было бы &ldquo;Oooops&rdquo;.</p>

<p>Возможно с первого раза разобраться с вариантностью будет сложно. Но есть некоторые правила для выбора вариантности. Они зависят от того, в какой позиции будет стоять переменная типа. Существуют ковариантные или положительные позиции и контравариантные или отрицательные позиции. Положительными считаются следующие позиции - это типы значений (полей данных) в классах/трейтах, типы результатов возвращаемых методами класса/трейта, а так же позиция в качестве аргумента для параметров типов других ковариантных классов. Отрицательными позициями считаются типы формальных параметров метода класса/трейта. Если сказать проще, то в общем случае изменяемые контейнеры должны быть инвариантные, неизменяемые контейнеры - ковариантные, входные значения для функций - контравариантные, а выходные - ковариантные. В любом случае компилятор Scala проверяет вариантность каждого параметра типа и если вы где-то напутали с вариантностью, то компилятор обязательно сообщит об этом и откажется компилировать код.</p>

<h3>Границы изменения типов</h3>

<p>Но иногда проверка вариативности мешает реализовать, в принципе, корректные вещи. Например, давайте добавим к нашему списку метод для добавления нового элемента:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="o">::(</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Мы добавляем этот метод непосредственно в базовый класс <code>List[+T]</code>. Между делом, данный метод не совсем обычный, дело в том, что в Scala все методы, которые заканчиваются на двоеточие имеют правую ассоциативность (мы увидим что это значит на примере ниже). К сожалению, приведенный код не компилируется и компилятор будет ругаться, что ковариантный тип T оказался в контравариантной позиции, то есть в качестве типа формального параметра <code>hd</code>. Обойти эту проблему можно сделав метод полиморфным, добавив еще один параметр типа:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="o">::[</span><span class="kt">B</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Теперь у метода <code>::</code> появился свой параметр типа <code>B</code>, и так как он является инвариантным (инвариантные типы могут появляться в любой позиции), то его появление в качестве типа формального параметра функции не должно вызывать проблем. Однако, проблема появляется в реализации данного метода. Теперь, мы не можем конструировать новый список путем добавления элемента типа <code>B</code> к списку элементов типа <code>T</code>. И это логически верно, ведь параметр типа <code>B</code> может представлять любой тип. Вот если бы его можно было как-то ограничить только допустимыми типами. Это делается следующим образом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="o">::[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>То есть мы добавили <code>&gt;: T</code> к параметру типа, тем самым указав, что тип <code>T</code> является нижней границей типа <code>B</code> (<code>B</code> должен быть супер-типом для <code>T</code>). И с указанием данного условия код успешно компилируется. Также, благодаря добавлению параметра типа к методу <code>::</code>, мы дополнительно улучшили его реализацию. Если мы добавим элемент с типом отличающимся от исходного типа списка, то результирующий список изменит свой тип в сторону типа нового элемента. Давайте посмотрим на примере:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="s">&quot;one&quot;</span> <span class="o">::</span> <span class="s">&quot;two&quot;</span> <span class="o">::</span> <span class="s">&quot;three&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">anyRefString</span> <span class="k">=</span> <span class="nc">AnyRef</span> <span class="o">::</span> <span class="n">strings</span> <span class="c1">// anyRefString будет типа List[Object]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="s">&quot;one&quot;</span> <span class="o">::</span> <span class="s">&quot;two&quot;</span> <span class="o">::</span> <span class="s">&quot;three&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'><span class="n">strings</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">one</span> <span class="o">::</span> <span class="n">two</span> <span class="o">::</span> <span class="n">three</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">anyRefString</span> <span class="k">=</span> <span class="nc">AnyRef</span> <span class="o">::</span> <span class="n">strings</span>
</span><span class='line'><span class="n">anyRefString</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span> <span class="k">object</span> <span class="nc">AnyRef</span> <span class="o">::</span> <span class="n">one</span> <span class="o">::</span> <span class="n">two</span> <span class="o">::</span> <span class="n">three</span> <span class="o">::</span> <span class="nc">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Обратите внимание на то, как конструируется новый список в первой строке. Такая запись возможна благодаря правой ассоциативности метода <code>::</code>. Если переписать это выражение в более привычный вид, это будет выглядеть вот так:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Nil</span><span class="o">.::(</span><span class="s">&quot;three&quot;</span><span class="o">).::(</span><span class="s">&quot;two&quot;</span><span class="o">).::(</span><span class="s">&quot;one&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Помимо указания нижней границы, можно также указывать и верхнюю границу типа <code>T &lt;: U</code>, например:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">personName</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Person</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="k">def</span> <span class="n">studentName</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Student</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">students</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'><span class="k">val</span> <span class="n">persons</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="n">students</span>
</span><span class='line'>
</span><span class='line'><span class="n">students</span> <span class="n">map</span> <span class="n">personName</span>
</span><span class='line'><span class="n">students</span> <span class="n">map</span> <span class="n">studentName</span>
</span><span class='line'>
</span><span class='line'><span class="n">persons</span> <span class="n">map</span> <span class="n">studentName</span> <span class="c1">// ошибка</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>repl</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">personName</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Person</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="n">personName</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Person</span><span class="err">]</span><span class="o">(</span><span class="kt">p:</span> <span class="kt">T</span><span class="o">)</span><span class="kt">String</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">studentName</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Student</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="n">studentName</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Student</span><span class="err">]</span><span class="o">(</span><span class="kt">s:</span> <span class="kt">T</span><span class="o">)</span><span class="kt">String</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">students</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Student</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'><span class="n">students</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Bob</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">persons</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="n">students</span>
</span><span class='line'><span class="n">persons</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Bob</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">students</span> <span class="n">map</span> <span class="n">personName</span>
</span><span class='line'><span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Bob</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">students</span> <span class="n">map</span> <span class="n">studentName</span>
</span><span class='line'><span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Bob</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">map</span> <span class="n">studentName</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span><span class='line'> <span class="n">found</span>   <span class="k">:</span> <span class="kt">Student</span> <span class="o">=&gt;</span> <span class="nc">String</span>
</span><span class='line'> <span class="n">required</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="o">?</span>
</span><span class='line'>              <span class="n">persons</span> <span class="n">map</span> <span class="n">studentName</span>
</span><span class='line'>                          <span class="o">^</span>
</span></code></pre></td></tr></table></div></figure>


<p>Из примера видно, что у параметра типа функции <code>personName</code> в качестве верхней границы указан тип <code>Person</code> и данная функция успешно выполняется как с аргументами типа <code>Person</code>, так и с его подтипами, что соответствует заданной границе. Но в тоже время функция <code>studentName</code> вызывает ошибку при попытке передачи в нее аргументов типа <code>Person</code>, так как для параметра типа верхняя граница задана типом <code>Student</code>, соответственно эта функция допускает только аргументы с типом <code>Student</code> или его подтипами.</p>

<h2>Заключение</h2>

<p>Итак, мы прошли долгий путь и рассмотрели различные формы универсального полиморфизма. Мы узнали как при помощи выделения подтипов и параметризации достигать большей гибкости, увидели как эти возможности вместе с вариативностью помогают создавать обобщенный код и увеличивают возможности его повторного использования. Узнали как задание границ типов позволяет разрабатывать более типобезопасные решения.</p>

<p>В следующей статье мы рассмотрим ad-hoc полиморфизм и в его рамках познакомимся с такими понятиями как неявные преобразования, границы контекста и границы отображения, познакомимся с реализацией typeclass&#8217;ов.</p>

<p>Для того, что бы не раздувать объем статьи, за рамками рассмотрения остались такие связанные темы как: структурные типы, абстрактные типы, экзистенциальные типы, рекурсивные типы и возможно еще целый спектр возможностей системы типов Scala.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Json и Scala: Play Json Library]]></title>
    <link href="http://algolov.github.io/blog/2014/03/09/json-and-scala-play-json-library/"/>
    <updated>2014-03-09T17:13:48+10:00</updated>
    <id>http://algolov.github.io/blog/2014/03/09/json-and-scala-play-json-library</id>
    <content type="html"><![CDATA[<p><img src="http://algolov.github.io/images/json-and-scala/play_json_pic.png" width="350" height="350"></p>

<p>Данный пост входит в <a href="http://algolov.github.io/blog/2014/03/09/json-and-scala/">серию статей</a> на тему работы с JSON в Scala и в нем будет рассмотрена работа с библиотекой Play Json (<a href="https://github.com/playframework/playframework/tree/master/framework/src/play-json">github</a>, <a href="http://www.playframework.com/documentation/2.2.x/api/scala/index.html#play.api.libs.json.package">документация</a>). Код основного примера и каркаса приложения можно <a href="https://github.com/algolov/JsonSeries.git">посмотреть в репозитории на github</a>.</p>

<!-- more -->


<p>Данная библиотека была выделена из веб-фреймворка Play, который входит в Typesafe Reactive Platform и для парсинга JSON строк использует java-библиотеку <a href="http://jackson.codehaus.org/">Jackson</a>. Для того, что бы начать работать с библиотекой play json необходимо указать ее в качестве зависимости в вашем файле build.sbt:</p>

<figure class='code'><figcaption><span>build.sbt</span><a href='https://github.com/algolov/JsonSeries/blob/master/build.sbt#L14'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">libraryDependencies</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="s">&quot;com.typesafe.play&quot;</span> <span class="o">%%</span> <span class="s">&quot;play-json&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.1&quot;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>И написать 2 строчки импорта:</p>

<figure class='code'><figcaption><span>PlayJson.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/main/scala/com/github/algolov/libs/PlayJson.scala#L3'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">play.api.libs.json._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">play.api.libs.functional.syntax._</span>
</span></code></pre></td></tr></table></div></figure>


<p>Рассматривать возможности данной библиотеки я буду на основе примера описанного в <a href="http://algolov.github.io/blog/2014/03/09/json-and-scala/">заглавном посте</a> серии, с которым необходимо ознакомится для полного понимания сути происходящего.
Поэтому для начала, рассмотрим то, что предлагает нам библиотека Play Json, а затем как это использовать в рамках нашего примера.</p>

<h2>Play Json: Основные методы</h2>

<p>Для представления типов данных JSON в пакете <code>play.api.libs.json</code> существуют следующие типы данных:</p>

<figure class='code'><figcaption><span>JsValue.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala#L89'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/** Represent a Json null value. */</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">JsNull</span> <span class="k">extends</span> <span class="nc">JsValue</span> <span class="o">{...}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Represent a Json boolean value.*/</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Represent a Json number value. */</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsNumber</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Represent a Json string value. */</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Represent a Json array value. */</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span> <span class="k">extends</span> <span class="nc">JsValue</span> <span class="o">{...}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Represent a Json object value.*/</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">JsValue</span><span class="o">)])</span> <span class="k">extends</span> <span class="nc">JsValue</span> <span class="o">{...}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Как видно из листинга, все эти типы данных расширяют класс <code>JsValue</code>, который является супертипом для всех других JSON типов. Именно этот тип данных кодирует обобщенное понятие JSON, поэтому им мы и конкретизируем абстрактный член типа в трейте <code>JsonLibrary</code>.
Чтобы реализовать основную функциональность нашего трейта, посмотрим что нам предлагает содержащий статические методы <a href="https://www.playframework.com/documentation/2.2.x/api/scala/index.html#play.api.libs.json.Json$"><code>объект Json</code></a>:</p>

<figure class='code'><figcaption><span>Json.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/Json.scala#L16'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/** Parse a String representing a json, and return it as a JsValue. */</span>
</span><span class='line'> <span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsValue</span> <span class="o">=</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, для того чтобы разобрать строку представляющую json, необходимо просто передать ее в качестве параметра методу <code>parse</code>, обратно мы получим значение типа <code>JsValue</code>.</p>

<figure class='code'><figcaption><span>Json.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/Json.scala#L48'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/** Convert a JsValue to its string representation. */</span>
</span><span class='line'> <span class="k">def</span> <span class="n">stringify</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Для того, чтобы конвертировать <code>JsValue</code> обратно в строковое представление, необходимо передать значение этого типа в метод <code>stringify</code>.</p>

<p>С оставшимися двумя методами для сериализации/десериализации все немного сложнее:</p>

<figure class='code'><figcaption><span>Json.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/Json.scala#L83'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/** Provided a Reads implicit for its type is available, convert any object into a JsValue. */</span>
</span><span class='line'> <span class="k">def</span> <span class="n">toJson</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">tjs</span><span class="k">:</span> <span class="kt">Writes</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsValue</span> <span class="o">=</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Для того, что бы конвертировать значение <code>JsValue</code> в класс нашей модели (десериализовать), мы передаем это значение в метод <code>fromJson</code> и на выходе получаем значение типа <code>JsResult[T]</code>, где <code>T</code> это тип модели. Конвертировать значение типа <code>JsValue</code> в другой тип можно так же воспользовавшись методом <code>validate</code> трейта <code>JsValue</code>, который так же возвращает значение типа <code>JsResult[T]</code>:</p>

<figure class='code'><figcaption><span>JsValue.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala#L70'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">validate</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">rds</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Так что же представляет из себя тип <code>JsResult</code>? <code>JsResult[T]</code> это монадический тип, который может быть либо <code>JsSuccess[T]</code> содержащий результат конвертации, в том случае если конвертация была удачной, либо <code>JsError[T]</code> в обратном случае и содержать список всех ошибок встреченных при конвертировании. И так как это монадический тип, он содержит соответствующие методы (flatMap, map, &hellip;). Вкратце, в случае успешного конвертирования <code>JsResult</code> будет содержать экземпляр класса нашей модели, в обратном случае набор ошибок с указанием на каком этапе конвертирования эти ошибки встретились. Мы еще рассмотрим <code>JsResult</code> более подробно позже, пока же достаточно знать, что мы можем конвертировать значение это типа в значение типа <code>Option[T]</code> при помощи метода <code>asOpt</code>.</p>

<figure class='code'><figcaption><span>Json.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/Json.scala#L90'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/** Provided a Writes implicit for that type is available, convert a JsValue to any type. */</span>
</span><span class='line'><span class="k">def</span> <span class="n">fromJson</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">fjs</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Для сериализации класса в JSON передаем экземпляр класса в качестве параметра методу <code>toJson</code> и на выходе получаем значение <code>JsValue</code>.
Вся загвоздка с методами сериализации/десериализации в том, что у них есть дополнительный неявный список параметров, в котором передаются экземпляры классов <code>Reads[T]</code> и <code>Writes[T]</code> соответственно. Именно эти классы знают как правильно конвертировать типы Scala в <code>JsValue</code> и обратно. В Play json уже содержатся неявные (де)сериализаторы для основных типов данных Scala (<code>DefaultWrites</code> и <code>DefaultReads</code>). Но про то, как конвертировать экземпляры наших классов Play Json ничего не известно. Поэтому мы должны написать соответствующие неявные (де)сериализаторы самостоятельно и обеспечить их присутствие в области видимости там где они потребуются. Прежде чем это сделать, давайте посмотрим на код трейта <code>PlayJson</code> реализующий интерфейс <code>JsonLibrary</code>:</p>

<figure class='code'><figcaption><span>PlayJson.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/main/scala/com/github/algolov/libs/PlayJson.scala#L9'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">PlayJson</span> <span class="k">extends</span> <span class="nc">JsonLibrary</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">import</span> <span class="nn">PlayJson._</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">type</span> <span class="kt">JSON</span> <span class="o">=</span> <span class="nc">JsValue</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">parseFromString</span><span class="o">(</span><span class="n">jsonStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="n">jsonStr</span><span class="o">)</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">parseToString</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span>     <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">stringify</span><span class="o">(</span><span class="n">json</span><span class="o">)</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">serialize</span><span class="o">(</span><span class="n">listing</span><span class="k">:</span> <span class="kt">Listing</span><span class="o">)</span>      <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">toJson</span><span class="o">[</span><span class="kt">Listing</span><span class="o">](</span><span class="n">listing</span><span class="o">)</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span>       <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">fromJson</span><span class="o">[</span><span class="kt">Listing</span><span class="o">](</span><span class="n">json</span><span class="o">).</span><span class="n">asOpt</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>В этой реализации нет ничего особенного, мы просто используем методы описанные выше. Единственная неоговоренная строка - <code>import PlayJson._</code>. Она производит импорт содержимого объекта-компаньена <code>PlayJson</code>. В нем мы определим все необходимые неявные значения для конвертирования экземпляров наших кейс классов, данным импортом мы вводим их в область видимости, что бы они могли быть подхвачены методами нуждающимися в них. Что же содержит объект <code>PlayJson</code>? На самом деле совсем немного строк кода. Но для того, что бы написать их придется изучить немного теории.</p>

<h2>Play Json: Reads, Writes, Format и JsPath</h2>

<p>Итак мы выяснили, что для того, чтобы конвертировать JsValue в другой тип Scala и обратно нам необходимо предоставить в область видимости соответствующие значения <code>Reads[T]</code> и <code>Writes[T]</code> где <code>T</code> класс модели. Как мы увидим позже, эти конвертеры можно объединить. Но начнем рассматривать все по порядку, а для этого нам нужно познакомиться еще с одним парнем - <code>JsPath</code>.</p>

<h3>JsPath</h3>

<p><a href="http://www.playframework.com/documentation/2.2.x/api/scala/index.html#play.api.libs.json.JsPath">JsPath</a> это набор узлов которые надо обойти в структуре <code>JsValue</code>, чтобы получить значение. Попросту говоря, <code>JsPath</code> представляет собой путь до конкретного значения в json объекте, это практически тоже самое что и <code>XPath</code> для XML. Давайте посмотрим на определение <code>JsPath</code>:</p>

<figure class='code'><figcaption><span>JsPath.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/JsPath.scala#L164'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">PathNode</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">\(</span><span class="n">child</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span> <span class="o">:+</span> <span class="nc">KeyPathNode</span><span class="o">(</span><span class="n">child</span><span class="o">))</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">\(</span><span class="n">child</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">)</span> <span class="k">=</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span> <span class="o">:+</span> <span class="nc">KeyPathNode</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="o">\\(</span><span class="n">child</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span> <span class="o">:+</span> <span class="nc">RecursiveSearch</span><span class="o">(</span><span class="n">child</span><span class="o">))</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">\\(</span><span class="n">child</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">)</span> <span class="k">=</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span> <span class="o">:+</span> <span class="nc">RecursiveSearch</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsPath</span> <span class="o">=</span> <span class="nc">JsPath</span><span class="o">(</span><span class="n">path</span> <span class="o">:+</span> <span class="nc">IdxPathNode</span><span class="o">(</span><span class="n">idx</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="n">path</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">json</span><span class="o">))((</span><span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">apply</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Как видно из листинга <code>JsPath</code> это список узлов пути <code>List[PathNode]</code> и набор операций над этим списком. Методы <code>\</code> и <code>\\</code> имеют две версии. Это нужно для того, что бы можно было сформировать путь используя как строки (<code>JsPath \ "key1"</code>), так и символы (<code>JsPath \ 'key1</code>). Оба этих метода и первый метод <code>apply</code> формируют новый путь добавляя узлы соответствующих типов (они все расширяют <code>PathNode</code>) к исходному пути. Вторая версия <code>apply</code> применяет значение типа <code>JsValue</code> к сформированному пути, т.е. берем первый узел в пути и из переданного json-значения выбираем все дочерние ключи соответствующие этому узлу. Получается список значений <code>JsValue</code> (отобранные ключи). Затем берется следующий узел и из полученного списка выбирается все дочерние ключи, соответствующие новому узлу и так далее. Когда узлы в пути закончатся, то итоговый список значений <code>JsValue</code> как раз и будет результатом. Давайте посмотрим на примере и сформируем такой путь:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">path</span> <span class="k">=</span> <span class="nc">JsPath</span> <span class="o">\</span> <span class="s">&quot;key1&quot;</span> <span class="o">\</span> <span class="s">&quot;key2&quot;</span>
</span><span class='line'><span class="n">path</span><span class="k">:</span> <span class="kt">play.api.libs.json.JsPath</span> <span class="o">=</span> <span class="o">/</span><span class="n">key1</span><span class="o">/</span><span class="n">key2</span>
</span></code></pre></td></tr></table></div></figure>


<p>А теперь попробуем применить к этому пути различные json объекты:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">json1</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">obj</span><span class="o">(</span><span class="s">&quot;key1&quot;</span> <span class="o">-&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">obj</span><span class="o">(</span><span class="s">&quot;key2&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;value&quot;</span><span class="o">))</span>
</span><span class='line'><span class="n">json1</span><span class="k">:</span> <span class="kt">play.api.libs.json.JsObject</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;key1&quot;</span><span class="k">:</span><span class="o">{</span><span class="err">&quot;</span><span class="kt">key2</span><span class="err">&quot;</span><span class="kt">:</span><span class="err">&quot;</span><span class="kt">value</span><span class="err">&quot;</span><span class="o">}}</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">json2</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">obj</span><span class="o">(</span><span class="s">&quot;key1&quot;</span> <span class="o">-&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">obj</span><span class="o">(</span><span class="s">&quot;key2&quot;</span> <span class="o">-&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">arr</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)))</span>
</span><span class='line'><span class="n">json2</span><span class="k">:</span> <span class="kt">play.api.libs.json.JsObject</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;key1&quot;</span><span class="k">:</span><span class="o">{</span><span class="err">&quot;</span><span class="kt">key2</span><span class="err">&quot;</span><span class="kt">:</span><span class="o">[</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span>,<span class="err">4</span>,<span class="err">5</span><span class="o">]}}</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">path</span><span class="o">(</span><span class="n">json1</span><span class="o">)</span>
</span><span class='line'><span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">play.api.libs.json.JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">path</span><span class="o">(</span><span class="n">json2</span><span class="o">)</span>
</span><span class='line'><span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">play.api.libs.json.JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">([</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span>,<span class="err">4</span>,<span class="err">5</span><span class="o">])</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">path</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="n">json2</span><span class="o">)</span>
</span><span class='line'><span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">play.api.libs.json.JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, для того что бы сформировать путь, нам надо начать с объекта <code>JsPath</code>, который представляет корневой элемент пути и продолжить добавляя к нему соответствующие узлы, при помощи описанных выше методов. Для большего удобства и лучшего визуального выделения в объекте пакета json для объекта <code>JsPath</code> определен алиас: <code>__</code> так что путь из предыдущего примера можно переписать так:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">path</span> <span class="k">=</span> <span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;key1&quot;</span> <span class="o">\</span> <span class="s">&quot;key2&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Теперь, когда мы научились формировать путь, можно перейти к написанию непосредственно конвертеров.
Reads</p>

<p>Конвертеры <code>Reads[T]</code> используются для десериализации из <code>JsValue</code> в какой-нибудь другой тип <code>T</code>, например в класс модели <code>Listing</code>. <code>Reads[T]</code> можно комбинировать и вкладывать друг в друга, что бы получить более сложные конвертеры <code>Reads[T]</code>. Например для того, что бы получить десериализатор кейс класса <code>Counters</code>, нам необходимо объединить четыре десериализатора из <code>JsValue</code> в Int. А для того, что бы написать десериализатор для класса Link нам придется вложить десериализатор класса <code>Counters</code>. Давайте, напишем десериализатор для класса <code>Counters</code>. Так как все поля этого класса имеют стандартный тип Scala, это будет довольно просто и библиотека Play Json предлагает несколько способов сделать задуманное. Во первых, мы можем воспользоваться <code>JsPath</code> и его методами <code>read</code> и <code>readNullable</code>:</p>

<figure class='code'><figcaption><span>JsPath.scala</span><a href='https://github.com/playframework/playframework/blob/2.2.x/framework/src/play-json/src/main/scala/play/api/libs/json/JsPath.scala#L256'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">read</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</span><span class='line'><span class="k">def</span> <span class="n">readNullable</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Данные методы принимают в качестве параметра неявный конвертер типа <code>Reads[T]</code> и применяют его к значению извлеченному по указанному пути. Метод <code>readNullable</code> полезен в случае если значение по указанному пути равно <code>null</code> или не найдено, в таком случае он вернет <code>None</code>. Например следующий код:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">score</span> <span class="k">=</span> <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;before&quot;</span><span class="o">).</span><span class="n">readNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'><span class="n">score</span><span class="k">:</span> <span class="kt">play.api.libs.json.Reads</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">Reads$$anon$8</span><span class="k">@</span><span class="mi">707</span><span class="n">d7290</span>
</span></code></pre></td></tr></table></div></figure>


<p>Применит к значению ключа before неявный конвертер в тип String, который предоставляется Play Json:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">jStr</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromURL</span><span class="o">(</span><span class="n">getClass</span><span class="o">.</span><span class="n">getResource</span><span class="o">(</span><span class="s">&quot;/reddit.json&quot;</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">mkString</span>
</span><span class='line'><span class="n">jStr</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">json</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="n">jStr</span><span class="o">)</span>
</span><span class='line'><span class="n">json</span><span class="k">:</span> <span class="kt">play.api.libs.json.JsValue</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">fromJson</span><span class="o">(</span><span class="n">json</span><span class="o">)(</span><span class="n">score</span><span class="o">)</span>
</span><span class='line'><span class="n">res8</span><span class="k">:</span> <span class="kt">play.api.libs.json.JsResult</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">JsSuccess</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">t3_1ygz6x</span><span class="o">),/</span><span class="n">data</span><span class="o">/</span><span class="n">before</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, мы можем извлекать и конвертировать отдельные значения. Для того, что бы преобразовать эти отдельные значения в более сложный тип, например класс <code>Counters</code> необходимо скомбинировать конвертеры при помощи операции <code>and</code> или <code>~</code> (по сути <code>and</code> просто вызывает <code>~</code>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">paste</span>
</span><span class='line'><span class="k">val</span> <span class="n">countersCombReads</span> <span class="k">=</span>
</span><span class='line'><span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;ups</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'><span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;downs</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'><span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;score</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'><span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;num_comments</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Exiting paste mode, now interpreting.</span>
</span><span class='line'>
</span><span class='line'><span class="n">countersCombReads</span><span class="k">:</span> <span class="kt">FunctionalBuilder</span><span class="o">[</span><span class="kt">Reads</span><span class="o">]</span><span class="k">#</span><span class="nc">CanBuild4</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span>,<span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Как видно из листинга результатом такого комбинирования является экземпляр класса <code>FunctionalBuilder[Reads]#CanBuild4[Int,Int,Int,Int]</code>, не будем останавливаться на нем подробно. Можно воспринимать этот результат как промежуточный при построении более сложных конвертеров <code>Reads</code>. Главное знать, что таких типов <code>FunctionalBuilder[Reads]#CanBuildX</code> существует вплоть до X=22, то есть мы можем скомбинировать до 22 конвертеров <code>Reads</code> (известное ограничение в Scala) и если значению такого типа передать в его метод apply функцию формирования из отдельных значений экземпляр модели (метод <code>apply</code> у кейс класса), то мы получим составной конвертер для нашей модели:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">contersReads</span> <span class="k">=</span> <span class="n">countersCombReads</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="nc">Counters</span><span class="o">.</span><span class="n">apply</span> <span class="k">_</span><span class="o">)</span>
</span><span class='line'><span class="n">contersReads</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">Reads$$anon$8</span><span class="k">@</span><span class="mi">6</span><span class="n">e266f8f</span>
</span></code></pre></td></tr></table></div></figure>


<p>Более кратко все это можно записать следующим образом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">countersReads</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>     <span class="o">|</span> <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;ups</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>     <span class="o">|</span> <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;downs</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>     <span class="o">|</span> <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;score</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>     <span class="o">|</span> <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="-Symbol">&#39;num_comments</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="o">(</span><span class="nc">Counters</span><span class="o">.</span><span class="n">apply</span> <span class="k">_</span><span class="o">)</span>
</span><span class='line'><span class="n">countersReads</span><span class="k">:</span> <span class="kt">play.api.libs.json.Reads</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">Reads$$anon$8</span><span class="k">@</span><span class="mi">39</span><span class="n">e24635</span>
</span></code></pre></td></tr></table></div></figure>


<p>Понимая принцип создания сложных конвертеров из комбинации простых, последний листинг выглядит довольно простым. Однако библиотека Play Json предоставляет еще более простой способ. Создать десериализатор для вашей модели можно так же при помощи удобного метода reads объекта Json. Данный метод использует макросы введенные в Scala 2.10:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">reads</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span>
</span><span class='line'><span class="n">res25</span><span class="k">:</span> <span class="kt">play.api.libs.json.Reads</span><span class="o">[</span><span class="kt">Test.Counters</span><span class="o">]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">Reads$$anon$8</span><span class="k">@</span><span class="mi">26</span><span class="n">fbe9c1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Вот и все. Одна строка. Но у этого метода есть ряд ограничений:
- нельзя перегружать метод <code>apply</code> у кейс класса в объекте компаньене, потому что макрос не сможет выбрать между несколькими методами <code>apply</code>
- функции <code>apply</code> (и <code>unaply</code> в случае <code>write</code>) должны иметь соответствующие входные/выходные типы. У кейс классов это предоставляется автоматически, а для трейтов необходимо будет написать соответствующие методы <code>apply</code> и <code>unaply</code>. Обратите внимание как обрабатывается модель <code>Listing</code>, ниже
- Json макрос умеет обрабатывать следующие обобщенные типы <code>Option</code>, <code>Seq</code>, <code>List</code>, <code>Set</code> и <code>Map[String, _]</code>. В случае остальных придется отказаться от использования макросов.</p>

<p>Наименование полей данных в модели должно соответствовать наименованиям полей в json объекте.
Давайте теперь напишем десериализаторы для остальных моделей, начнем с модели для ссылок:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">linkReads</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">Link</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;title&quot;</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;url&quot;</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span><span class="n">map</span><span class="o">[</span><span class="kt">URL</span><span class="o">](</span><span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span>
</span><span class='line'><span class="o">)(</span><span class="nc">Link</span><span class="o">.</span><span class="n">apply</span> <span class="k">_</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Для поля <code>title</code> мы воспользовались неявным конвертером предоставляемым библиотекой. А для конвертирования поля <code>url</code>, я воспользовался удобным методом map и преобразовал конвертер строки в конвертер класса <code>URL</code>. Поля содержащиеся в классе <code>Counters</code>, иерархически находятся на одном уровне с полями <code>title</code> и <code>url</code>, поэтому конвертеру мы указываем просто путь <code>(__ \ "data")</code>, и так как ранее мы уже написали неявный конвертер для типа <code>Counters</code> никаких преобразований больше не требуется. Хотя, отдельный неявный конвертер для <code>Counters</code> можно было и не писать, а просто передать явно в качестве параметра:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>   <span class="o">...</span>
</span><span class='line'><span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Counters</span><span class="o">](</span><span class="nc">Json</span><span class="o">.</span><span class="n">reads</span><span class="o">[</span><span class="kt">Counters</span><span class="o">])</span>
</span><span class='line'>   <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Теперь настала очередь десериализатора для последней модели:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">listingFormat</span><span class="k">:</span> <span class="kt">Reads</span><span class="o">[</span><span class="kt">Listing</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;children&quot;</span><span class="o">).</span><span class="n">read</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">]]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;before&quot;</span><span class="o">).</span><span class="n">readNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;after&quot;</span><span class="o">).</span><span class="n">readNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'>  <span class="o">)(</span><span class="nc">Listing</span><span class="o">(</span><span class="nc">UUID</span><span class="o">.</span><span class="n">randomUUID</span><span class="o">(),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Здесь стоит отметить два момента. Во-первых, конвертер для поля <code>children</code>. Так как значением этого поля является массив объектов, соответствующих модели <code>Link</code> в нашем представлении, мы конвертируем его в коллекцию ссылок <code>Seq[Link]</code>. Это работает так как в play json уже есть неявный сериализатор для коллекций. Во-вторых, это способ формирования экземпляра нашей модели. Из-за того, что модель <code>Listing</code> имеет поле <code>id</code>, которое отсутствует в json, но должно быть задано при создании экземпляра, мы не можем использовать функцию <code>apply</code> модели. Вместо этого мы передаем лямбда выражение, формирующее функцию принимающую три параметра и возвращаю экземпляр класса <code>Lisitng</code>. Более развернуто это можно записать следующим образом:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">links</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">],</span> <span class="n">before</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">after</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Listing</span><span class="o">(</span><span class="nc">UUID</span><span class="o">.</span><span class="n">randomUUID</span><span class="o">(),</span> <span class="n">links</span><span class="o">,</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, с десериализаторами мы закончили переходим к написанию сериализаторов.</p>

<h3>Writes</h3>

<p>С сериализаторами все будет немного проще. Дело в том, что реализация сериализатора практически не отличается от десериализатора. Начнем с модели <code>Counters</code>. Когда мы писали для нее десериализатор, то в конце концов воспользовались методом <code>reads[T]</code> объекта Json, основанным на макросах. Как вы наверно догадались, существует такой же метод и для сериализатора:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">writes</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span>
</span><span class='line'><span class="n">res10</span><span class="k">:</span> <span class="kt">play.api.libs.json.OWrites</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">OWrites$$anon$2</span><span class="k">@</span><span class="mi">65</span><span class="n">b117cd</span>
</span></code></pre></td></tr></table></div></figure>


<p>Не будем реализовывать его в качестве отдельного неявного значения, а просто передадим его в качестве параметра при реализации сериализатора для модели <code>Link</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">linkWrites</span><span class="k">:</span> <span class="kt">Writes</span><span class="o">[</span><span class="kt">Link</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;title&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;url&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">[</span><span class="kt">URL</span><span class="o">](</span><span class="k">new</span> <span class="nc">Writes</span><span class="o">[</span><span class="kt">URL</span><span class="o">]{</span> <span class="k">def</span> <span class="n">writes</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">URL</span><span class="o">)</span> <span class="k">=</span> <span class="nc">JsString</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span> <span class="o">})</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">[</span><span class="kt">Counters</span><span class="o">](</span><span class="nc">Json</span><span class="o">.</span><span class="n">writes</span><span class="o">[</span><span class="kt">Counters</span><span class="o">])</span>
</span><span class='line'><span class="o">)(</span><span class="n">unlift</span><span class="o">(</span><span class="nc">Link</span><span class="o">.</span><span class="n">unapply</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, перечислим основные отличия. Для поля url мы создаем новый конвертер <code>Writes[URL]</code> и реализуем логику конвертирования в методе writes, так как к экземпляру класса <code>Write[T]</code> метод map не применим. Для того, что бы сформировать из экземпляра нашей модели, несколько значений (те члены класса которые необходимо сериализовать), мы используем функцию unapply, но так как результат этой функции будет <code>Option[(String, URL, Counters)]</code> вместо (<code>String</code>, <code>URL</code>, <code>Counters</code>) мы трансформируем ее при помощи функции <code>unlift</code>.
И в заключении сериализатор для модели <code>Listing</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">listingWrites</span><span class="k">:</span> <span class="kt">Writes</span><span class="o">[</span><span class="kt">Listing</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;children&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">]]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;before&quot;</span><span class="o">).</span><span class="n">writeNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>  <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;after&quot;</span><span class="o">).</span><span class="n">writeNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'><span class="o">)(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">before</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">after</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Единственное отличие здесь это то, что вместо метода <code>unapply</code> мы передаем лямбду возвращающую только три поля и игнорирующую поле <code>id</code>, которое не требует сериализации.
И вот наконец-то мы разобрались с сериализаторами и десериализаторами и казалось бы на этом можно ставить точку. Однако Play Json предоставляет возможность объединить написание сериализатора и десериализатора в одном классе.</p>

<h3>Format</h3>

<p><code>Format[T]</code> это просто смесь из конвертеров <code>Reads[T]</code> и <code>Writes[T]</code>. Для того, что бы создать <code>Format[T]</code> можно воспользоваться, например, методом на основе макросов:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Json</span><span class="o">.</span><span class="n">format</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span>
</span><span class='line'><span class="n">res0</span><span class="k">:</span> <span class="kt">play.api.libs.json.OFormat</span><span class="o">[</span><span class="kt">Counters</span><span class="o">]</span> <span class="k">=</span> <span class="n">play</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">libs</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="nc">OFormat$$anon$1</span><span class="k">@</span><span class="mi">4</span><span class="n">c34c60e</span>
</span></code></pre></td></tr></table></div></figure>


<p>Или можно воспользоваться уже имеющимися конверторами Reads и Writes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">linkFormat</span><span class="k">:</span> <span class="kt">Format</span><span class="o">[</span><span class="kt">Link</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Format</span><span class="o">(</span><span class="n">linkReads</span><span class="o">,</span> <span class="n">linkWrites</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Также можно написать конвертеры с нуля, воспользовавшись комбинаторами:</p>

<figure class='code'><figcaption><span>PlayJson.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/main/scala/com/github/algolov/libs/PlayJson.scala#L22'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">linkFormat</span><span class="k">:</span> <span class="kt">Format</span><span class="o">[</span><span class="kt">Link</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;title&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;url&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span><span class="n">inmap</span><span class="o">[</span><span class="kt">URL</span><span class="o">](</span><span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">Counters</span><span class="o">](</span><span class="nc">Json</span><span class="o">.</span><span class="n">format</span><span class="o">[</span><span class="kt">Counters</span><span class="o">])</span>
</span><span class='line'>  <span class="o">)(</span><span class="nc">Link</span><span class="o">.</span><span class="n">apply</span><span class="o">,</span> <span class="n">unlift</span><span class="o">(</span><span class="nc">Link</span><span class="o">.</span><span class="n">unapply</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Для поля <code>title</code> используется конвертер по умолчанию. Для поля <code>url</code> мы преобразовываем стандартный конвертер <code>Format[String]</code> в конвертер <code>Format[URL]</code> воспользовавшись методом <code>inmap</code> и передав в него функции для создания <code>URL</code> из строки и обратно. И так как <code>Format[Link]</code> объединяет в себе сериализатор и десериализатор, результатом объединения путей будет тип <code>FunctionalBuilder[OFormat]#CanBuild3[String,URL,Counters]</code>, в функцию apply которого необходимо передать две функции для построения объекта модели из отдельных значений его полей и обратно. В создании <code>Format[Listing]</code> тоже нет ничего неожиданного:</p>

<figure class='code'><figcaption><span>PlayJson.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/main/scala/com/github/algolov/libs/PlayJson.scala#L28'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">listingFormat</span><span class="k">:</span> <span class="kt">Format</span><span class="o">[</span><span class="kt">Listing</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;children&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">]]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;before&quot;</span><span class="o">).</span><span class="n">formatNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;after&quot;</span><span class="o">).</span><span class="n">formatNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'>    <span class="o">)(</span><span class="nc">Listing</span><span class="o">(</span><span class="nc">UUID</span><span class="o">.</span><span class="n">randomUUID</span><span class="o">(),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">),</span> <span class="n">l</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">before</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">after</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, разобравшись с теорией, вернемся к объекту PlayJson нашего приложения. Вот его реализация:</p>

<figure class='code'><figcaption><span>PlayJson.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/main/scala/com/github/algolov/libs/PlayJson.scala#L20'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">PlayJson</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">linkFormat</span><span class="k">:</span> <span class="kt">Format</span><span class="o">[</span><span class="kt">Link</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;title&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;url&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span><span class="n">inmap</span><span class="o">[</span><span class="kt">URL</span><span class="o">](</span><span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">Counters</span><span class="o">](</span><span class="nc">Json</span><span class="o">.</span><span class="n">format</span><span class="o">[</span><span class="kt">Counters</span><span class="o">])</span>
</span><span class='line'>  <span class="o">)(</span><span class="nc">Link</span><span class="o">.</span><span class="n">apply</span><span class="o">,</span> <span class="n">unlift</span><span class="o">(</span><span class="nc">Link</span><span class="o">.</span><span class="n">unapply</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">listingFormat</span><span class="k">:</span> <span class="kt">Format</span><span class="o">[</span><span class="kt">Listing</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;children&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">]]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;before&quot;</span><span class="o">).</span><span class="n">formatNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">~</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">__</span> <span class="o">\</span> <span class="s">&quot;data&quot;</span> <span class="o">\</span> <span class="s">&quot;after&quot;</span><span class="o">).</span><span class="n">formatNullable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'>    <span class="o">)(</span><span class="nc">Listing</span><span class="o">(</span><span class="nc">UUID</span><span class="o">.</span><span class="n">randomUUID</span><span class="o">(),</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">),</span> <span class="n">l</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">l</span><span class="o">.</span><span class="n">data</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">before</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">after</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Обратите внимание на порядок объявления неявных значений. Так как <code>linkFormat</code> используется при создании <code>listingFormat</code>, в таком виде он обязательно должен предшествовать созданию <code>listingFormat</code>. Иначе, при выполнении тестов, вы получите не очень информативное исключение времени исполнения - <code>java.lang.NullPointerException</code></p>

<h3>Тесты</h3>

<p>После того как мы разобрались как сериализовывать/десериализовывать данные при помощи библиотеки Play Json. Давайте реализуем и запустим тесты. Для этого просто создадим две спецификации, расширив соответствующие спецификации для тестов функциональности и тестов производительности:</p>

<figure class='code'><figcaption><span>PlayJsonFunctionalitySpec.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/test/scala/com/github/algolov/libs/PlayJsonFunctionalitySpec.scala#L3'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">PlayJsonFunctionalitySpec</span> <span class="k">extends</span> <span class="nc">JsonLibraryFunctionalitySpec</span> <span class="k">with</span> <span class="nc">PlayJson</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;Play Json&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>и</p>

<figure class='code'><figcaption><span>PlayJsonPerfomanceSpec.scala</span><a href='https://github.com/algolov/JsonSeries/blob/master/src/test/scala/com/github/algolov/libs/PlayJsonPerfomanceSpec.scala'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">PlayJsonPerfomanceSpec</span> <span class="k">extends</span> <span class="nc">JsonLibraryPerfomanceSpec</span> <span class="k">with</span> <span class="nc">PlayJson</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;Play Json&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Запустим и посмотрим на результаты:</p>

<p><img src="http://algolov.github.io/images/json-and-scala/play_json_tests.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Json и Scala]]></title>
    <link href="http://algolov.github.io/blog/2014/03/09/json-and-scala/"/>
    <updated>2014-03-09T17:13:48+10:00</updated>
    <id>http://algolov.github.io/blog/2014/03/09/json-and-scala</id>
    <content type="html"><![CDATA[<p>В экосистеме Scala довольно много библиотек для работы с json, включая стандартную и исключая java-библиотеки. Данный пост начинает серию статей по использованию различных библиотек для работы с json в Scala. Эта серия статей не претендует на полноценный охват всех возможных библиотек или всех возможностей в библиотеках. Основная цель - понять как работать с json при помощи нескольких популярных библиотек.</p>

<!-- more -->


<p>Для рассмотрения предполагается следующий список (порядок случайный):</p>

<table>
<thead>
<tr>
<th>Статья   </th>
<th style="text-align:center;">   Библиотека        </th>
<th>   Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://algolov.github.io/blog/2014/03/09/json-and-scala-play-json-library">play json</a> </td>
<td style="text-align:center;"> <a href="http://www.playframework.com/documentation/2.2.x/ScalaJson">Play Json</a>           </td>
<td> Библиотека для работы с json выделенная из популярного web framework&#8217;а - Play</td>
</tr>
<tr>
<td></td>
<td style="text-align:center;"> <a href="https://github.com/spray/spray-json">Spray Json</a>          </td>
<td> Библиотека выделенная из проекта spray (инструментарий для организации REST/HTTP слоя поверх akka).</td>
</tr>
<tr>
<td></td>
<td style="text-align:center;"> <a href="http://argonaut.io">Argonaut</a>            </td>
<td> Библиотека использующая в своей основе только функциональную парадигму, то есть pure functional by design, активно использует ScalaZ.</td>
</tr>
</tbody>
</table>


<blockquote><p><strong>Обновление</strong>
К сожалению, нет времени закончить эту серию и написать все запланированные посты. Тем не менее, все запланированные библиотеки были рассмотрены в коде, который можно посмотреть на github - <a href="https://github.com/algolov/JsonSeries.git">https://github.com/algolov/JsonSeries.git</a></p></blockquote>

<p>В конце серии планируется заключительный пост со сравнением всех библиотек. В качестве сквозного примера будет использоваться список ссылок с сайта <a href="http://www.reddit.com/r/scala/.json">reddit.com в json</a>, конкретно <a href="http://www.reddit.com/r/scala">Scala subreddit</a>. В данном посте я опишу каркас, который будет использоваться при описании каждой из библиотек.</p>

<h2>Каркас приложения</h2>

<p>Если посмотреть на <a href="https://www.blogger.com/github.com/reddit/reddit/wiki/JSON">описание json объектов</a> возвращаемых JSON API reddit&#8217;a, то мы увидим, что для представления длинного содержимого используются объекты <code>Listing</code>, которые имеют три основных поля: <code>before</code>, <code>after</code> и <code>data</code>. Первые два служат для указания элемента в листинге с которого начинать разделение. А вот поле <code>data</code> как раз содержит список элементов, которые оборачивает данный листинг, в нашем примере это будут ссылки в сабреддите Scala. Так как основная цель это сравнить различные json библиотеки, а не написать свой клиент для reddit.com все модели предельно упрощены и заточены на то, чтобы показать различные сценарии работы с json. Итак, класс представляющий листинг:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Listing</span> <span class="o">(</span>
</span><span class='line'>  <span class="n">id</span><span class="k">:</span> <span class="kt">UUID</span> <span class="o">=</span> <span class="nc">UUID</span><span class="o">.</span><span class="n">randomUUID</span><span class="o">(),</span>
</span><span class='line'>  <span class="n">data</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Link</span><span class="o">],</span>
</span><span class='line'>  <span class="n">before</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
</span><span class='line'>  <span class="n">after</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Поле id было добавлено просто для того, что бы смоделировать сценарий, когда в модели есть поля, которые не должны быть сериализованны, но должны быть заданы при десериализации. Можно представить, что мы хотели бы хранить экземпляры листингов для каких-нибудь своих загадочных целей и различать их по uuid.
Следующий класс <code>Link</code>, представляющий ссылку:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Link</span><span class="o">(</span>
</span><span class='line'>  <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
</span><span class='line'>  <span class="n">url</span><span class="k">:</span> <span class="kt">URL</span><span class="o">,</span>
</span><span class='line'>  <span class="n">stats</span><span class="k">:</span> <span class="kt">Counters</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Оригинальный объект <code>Link</code> содержит гораздо большее количество полей, но нам вполне хватит нескольких. Последнее поле - stats, представляет собой различную количественную информацию о ссылке, выделенную в отдельный класс:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Counters</span> <span class="o">(</span>
</span><span class='line'>  <span class="n">ups</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
</span><span class='line'>  <span class="n">downs</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
</span><span class='line'>  <span class="n">score</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
</span><span class='line'>  <span class="n">num_comments</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Итак, представленный набор классов позволит рассмотреть распространенные сценарии работы с json. Теперь перейдем к описанию рассматриваемой функциональности json библиотек. Вся функциональность выливается в четыре абстрактных метода трейта <code>JsonLibrary</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">JsonLibrary</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">JSON</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">parseFromString</span> <span class="o">(</span><span class="n">jsonStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">JSON</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">parseToString</span> <span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JSON</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">serialize</span><span class="o">(</span><span class="n">listing</span><span class="k">:</span> <span class="kt">Listing</span><span class="o">)</span><span class="k">:</span> <span class="kt">JSON</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JSON</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Listing</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Так как каждая библиотека для кодирования понятия JSON имеет свой конкретный тип, то в трейте присутствует абстрактное поле, представляющее этот тип (abstract type member): <code>type JSON</code>. Каждая рассматриваемая библиотека будет расширять данный трейт, конкретизируя какой тип будет использоваться в качестве представления JSON и реализовывать весь набор операций в соответствии со своим API.
Для того, что бы получить начальное строковое представление json с которым будет вестись работа, напишем вспомогательный метод, который будет считывать соответствующие данные с сайта www.reddit.com или из заранее подготовленного локального файла, расположенного в ресурсах:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">loadListing</span><span class="o">(</span>
</span><span class='line'>  <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
</span><span class='line'>  <span class="n">before</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">,</span>
</span><span class='line'>  <span class="n">after</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">scalaSubredditUrl</span> <span class="k">=</span> <span class="s">&quot;http://www.reeddit.com/r/scala/.json&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">resp</span> <span class="k">=</span> <span class="nc">Try</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">(</span><span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="nc">Source</span><span class="o">.</span><span class="n">fromURL</span><span class="o">(</span><span class="n">scalaSubredditUrl</span> <span class="o">+</span> <span class="n">s</span><span class="s">&quot;?count=$count&amp;before=$b&quot;</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="nc">Source</span><span class="o">.</span><span class="n">fromURL</span><span class="o">(</span><span class="n">scalaSubredditUrl</span> <span class="o">+</span> <span class="n">s</span><span class="s">&quot;?count=$count&amp;after=$a&quot;</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromURL</span><span class="o">(</span><span class="n">scalaSubredditUrl</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span> <span class="n">getOrElse</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromURL</span><span class="o">(</span><span class="n">getClass</span><span class="o">.</span><span class="n">getResource</span><span class="o">(</span><span class="s">&quot;/reddit.json&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">resp</span><span class="o">.</span><span class="n">getLines</span><span class="o">().</span><span class="n">mkString</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Параметры данного метода позволяют &ldquo;пролистать&rdquo; листинги, указав направление и количество просмотренных ссылок (см. <a href="http://www.reddit.com/dev/api">reddit api</a>). И для того что бы удостоверится, что все работает верно - напишем несколько тестов, для этого будет использоваться замечательный тестовый фреймворк ScalaTest.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">UnitJsonSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="k">with</span> <span class="nc">OptionValues</span> <span class="k">with</span> <span class="nc">JsonLibrary</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">jsonString</span> <span class="k">=</span> <span class="n">loadListing</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Трейт <code>UnitJsonSpec</code> является базовым трейтом. Он смешивает общие для всех спецификаций трейты и загружающий текст с json.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">JsonLibraryFunctionalitySpec</span> <span class="k">extends</span> <span class="nc">UnitJsonSpec</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">name</span> <span class="n">should</span> <span class="s">&quot;parse a String representing a json, and return it as a json value and vice versa&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">strJson</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;{&quot;key1&quot;:1,&quot;key2&quot;:[1,2,3,4,5]}&quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">parseToString</span><span class="o">(</span><span class="n">parseFromString</span><span class="o">(</span><span class="n">strJson</span><span class="o">))</span> <span class="n">shouldBe</span> <span class="n">strJson</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;serialize and deserialize a json to scala classes and vice versa&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">import</span> <span class="nn">com.github.algolov.Listing</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="n">json</span> <span class="k">=</span> <span class="n">parseFromString</span><span class="o">(</span><span class="n">jsonString</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">listing</span> <span class="k">=</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">json</span><span class="o">).</span><span class="n">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">listing</span> <span class="n">shouldBe</span> <span class="n">a</span> <span class="o">[</span><span class="kt">Listing</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="n">listing2</span> <span class="k">=</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">serialize</span><span class="o">(</span><span class="n">listing</span><span class="o">)).</span><span class="n">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">listing2</span> <span class="n">should</span> <span class="n">have</span> <span class="o">(</span>
</span><span class='line'>      <span class="-Symbol">&#39;before</span> <span class="o">(</span><span class="n">listing</span><span class="o">.</span><span class="n">before</span><span class="o">),</span>
</span><span class='line'>      <span class="-Symbol">&#39;after</span> <span class="o">(</span><span class="n">listing</span><span class="o">.</span><span class="n">after</span><span class="o">)</span> <span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">listing2</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">length</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="n">listing</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Трейт <code>JsonLibraryFunctionalitySpec</code> это спецификация содержащая тесты основной функциональности библиотек. Все спецификации рассматриваемых библиотек расширяют данную спецификацию, реализуя метод name и наследуя все тесты, а так же примешивают конкретную реализацию <code>JsonLibrary</code> для переопределения абстрактных методов.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">JsonLibraryPerfomanceSpec</span> <span class="k">extends</span> <span class="nc">UnitJsonSpec</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">numIterations</span> <span class="k">=</span> <span class="mi">2000</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">repeat</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="n">f</span><span class="o">;</span> <span class="n">repeat</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">json</span> <span class="k">=</span> <span class="n">parseFromString</span><span class="o">(</span><span class="n">jsonString</span><span class="o">)</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">listing</span> <span class="k">=</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">json</span><span class="o">).</span><span class="n">value</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">name</span> <span class="n">should</span> <span class="n">s</span><span class="s">&quot;parse a json $numIterations times (iteration )&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">repeat</span><span class="o">(</span><span class="n">numIterations</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">parseFromString</span><span class="o">(</span><span class="n">jsonString</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">name</span> <span class="n">should</span> <span class="n">s</span><span class="s">&quot;deserialize from a json $numIterations times&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">repeat</span><span class="o">(</span><span class="n">numIterations</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">deserialize</span><span class="o">(</span><span class="n">json</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">name</span> <span class="n">should</span> <span class="n">s</span><span class="s">&quot;serialize to a json $numIterations times&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">repeat</span><span class="o">(</span><span class="n">numIterations</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">serialize</span><span class="o">(</span><span class="n">listing</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>JsonLibraryPerfomanceSpec</code> спецификация, содержащая тесты производительности json библиотек. Данные тесты, как и тесты обзорной функциональности, не претендуют на какой-либо серьезный бэнчмаркинг и добавлены лишь для поверхностного сравнения. Так что, если интересует серьезный тест производительности json библиотек, то не стоит принимать в расчет цифры полученные в результате этих тестов.</p>

<h2>Исходники и запуск</h2>

<p>Исходные тексты можно найти в соответствующем <a href="https://github.com/algolov/JsonSeries.git">репозитории на github</a>. Для запуска необходимо клонировать репозиторий, зайти в директорию JsonSeries и в командной строке выполнить команду <code>sbt test</code>. Для того, что бы запустить только тесты производительности нужно выполнить следующую команду: <code>sbt "test-only *PerfomanceSpec"</code> по этому же принципу можно указать и тесты конкретных библиотек или просмотреть только тесты функциональности. Данные команды загрузят необходимые зависимости, скомпилируют исходные файлы и запустят тесты на выполнение.</p>
]]></content>
  </entry>
  
</feed>
